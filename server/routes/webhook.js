import express from 'express'
import axios from 'axios'
import { getDatabase } from '../database/init.js'
import { generateThumbnailFromTelegramUrl } from '../utils/thumbnailGenerator.js'

const router = express.Router()

// ============================================================================
// üè∑Ô∏è –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ö–ê–¢–ï–ì–û–†–ò–ô
// ============================================================================

// –ú–∞–ø–ø–∏–Ω–≥ —Ç–µ–≥–æ–≤ –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (—Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º)
const CATEGORY_MAPPING = {
  // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
  '#just_chatting': 'just_chatting',
  '#–∏—Ä–ª': 'irl', 
  '#—Ñ–∏–ª—å–º': 'movies',
  '#–∏–≥—Ä—ã': 'gaming',
  '#–∫–æ–Ω—Ç–µ–Ω—Ç': 'content',
  '#–º–∞—Ä–∞—Ñ–æ–Ω': 'marathon',
  '#–∫—É–∫–∏–Ω–≥': 'cooking',
  '#—à–æ—É': 'show',
  '#—à–µ–ø—Ç—É–Ω—å–∏': 'show',
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
  '#—Ñ–∏–ª—å–º—ã': 'movies',
  '#–º—É–ª—å—Ç–∏–∫': 'movies', 
  '#–º—É–ª—å—Ç–∏–∫–∏': 'movies',
  '#–º—É–ª—å—Ç—Ñ–∏–ª—å–º': 'movies',
  '#–∫–∏–Ω–æ': 'movies',
  
  '#–∏–≥—Ä–∞': 'gaming',
  '#gaming': 'gaming',
  '#game': 'gaming',
  '#–≥–µ–π–º—Å': 'gaming',
  '#play': 'gaming',
  
  '#irl': 'irl',
  '#real': 'irl',
  '#–∂–∏–∑–Ω—å': 'irl',
  
  '#cooking': 'cooking',
  '#–≥–æ—Ç–æ–≤–∫–∞': 'cooking',
  '#–∫—É—Ö–Ω—è': 'cooking',
  '#–µ–¥–∞': 'cooking',
  
  '#marathon': 'marathon',
  '#–º–∞—Ä–∏–∫': 'marathon',
  '#–¥–æ–ª–≥–∏–π': 'marathon',
  
  '#show': 'show',
  '#—à–æ—É': 'show',
  '#program': 'show',
  '#–ø—Ä–æ–≥—Ä–∞–º–º–∞': 'show',
  
  '#content': 'content',
  '#–≤–∏–¥–µ–æ': 'content',
  '#video': 'content',
  
  // Fallback –∫–∞—Ç–µ–≥–æ—Ä–∏—è
  DEFAULT: 'just_chatting'
}

// –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
const TAG_REGEX = /#[a-zA-Z0-9–∞-—è—ë–ê-–Ø–Å_]+/gi // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ä—É—Å—Å–∫–∏—Ö –±—É–∫–≤ + —Ä–µ–≥–∏—Å—Ç—Ä
const DATE_REGEX = /\b\d{1,2}\.\d{1,2}\.(\d{2}|\d{4})\b/

// ============================================================================
// ü§ñ –û–ë–†–ê–ë–û–¢–ö–ê –ö–û–ú–ê–ù–î –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô
// ============================================================================

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
async function sendMessage(chatId, text, replyMarkup = null) {
  const botToken = process.env.TELEGRAM_BOT_TOKEN
  
  if (!botToken) {
    console.error('‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω')
    return false
  }

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`
  
  const payload = {
    chat_id: chatId,
    text: text,
    parse_mode: 'Markdown'
  }

  if (replyMarkup) {
    payload.reply_markup = replyMarkup
  }

  try {
    const response = await axios.post(url, payload)
    return response.data.ok
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error.response?.data || error.message)
    return false
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
async function handleUserMessage(message, res) {
  const chatId = message.chat.id
  const text = message.text || ''
  const userId = message.from.id
  const userName = message.from.first_name || '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'
  
  console.log(`üë§ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${userName} (ID: ${userId})`)
  console.log(`üí¨ –¢–µ–∫—Å—Ç: "${text}"`)
  
  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥—É /start
  if (!text.startsWith('/start')) {
    console.log('‚ùå –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ - –Ω–µ –∫–æ–º–∞–Ω–¥–∞ /start')
    return res.status(200).json({ ok: true, message: 'Not a start command' })
  }
  
  console.log('‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start')
  
  // –ü–æ–ª—É—á–∞–µ–º URL Mini App
  const miniAppUrl = process.env.MINI_APP_URL || 'https://your-mini-app.com'
  
  // –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
  const welcomeMessage = `üé¨ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞—Ä—Ö–∏–≤ —Å—Ç—Ä–∏–º–æ–≤ GENSYXA!

üëá –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ:`
  
  // Inline –∫–Ω–æ–ø–∫–∞ –¥–ª—è Mini App
  const inlineKeyboard = {
    inline_keyboard: [
      [
        {
          text: 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
          web_app: {
            url: miniAppUrl
          }
        }
      ]
    ]
  }
  
  // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
  const sent = await sendMessage(chatId, welcomeMessage, inlineKeyboard)
  
  if (sent) {
    console.log('‚úÖ –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ')
    return res.status(200).json({ ok: true, message: 'Start command processed' })
  } else {
    console.log('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ')
    return res.status(500).json({ ok: false, message: 'Failed to send message' })
  }
}

// ============================================================================
// üñºÔ∏è –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–†–ï–í–¨–Æ
// ============================================================================

async function generateThumbnail(telegramUrl) {
  const result = await generateThumbnailFromTelegramUrl(telegramUrl)
  
  if (result) {
    return result
  }
  
  return null
}

// ============================================================================
// üìù –ü–ê–†–°–ò–ù–ì –ü–û–°–¢–û–í
// ============================================================================

/**
 * –£–¥–∞–ª—è–µ—Ç —ç–º–æ–¥–∑–∏ –∏–∑ –Ω–∞—á–∞–ª–∞ —Å—Ç—Ä–æ–∫–∏
 * @param {string} text - –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
 * @returns {string} - –¢–µ–∫—Å—Ç –±–µ–∑ —ç–º–æ–¥–∑–∏ –≤ –Ω–∞—á–∞–ª–µ
 */
function removeLeadingEmojis(text) {
  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —ç–º–æ–¥–∑–∏ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
  // –ü–æ–∫—Ä—ã–≤–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –±–ª–æ–∫–∏ —ç–º–æ–¥–∑–∏ Unicode
  const emojiRegex = /^[\u{1F600}-\u{1F64F}|\u{1F300}-\u{1F5FF}|\u{1F680}-\u{1F6FF}|\u{1F1E0}-\u{1F1FF}|\u{2600}-\u{26FF}|\u{2700}-\u{27BF}|\u{1F900}-\u{1F9FF}|\u{1F018}-\u{1F270}|\u{238C}-\u{2454}|\u{20D0}-\u{20FF}|\u{FE0F}|\u{200D}|\s]+/gu
  
  return text.replace(emojiRegex, '').trim()
}

/**
 * –ü–∞—Ä—Å–∏—Ç –ø–æ—Å—Ç –∫–∞–Ω–∞–ª–∞ –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ —Å—Ç—Ä–∏–º–µ
 * @param {object} channelPost - –û–±—ä–µ–∫—Ç –ø–æ—Å—Ç–∞ –∏–∑ Telegram
 * @returns {object|null} - –î–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∏–º–∞ –∏–ª–∏ null –µ—Å–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥ –Ω–µ—É–¥–∞—á–µ–Ω
 */
function parsePost(channelPost) {
  const text = channelPost.text || channelPost.caption || ''
  
  if (!text.trim()) {
    console.log('   ‚ùå –ü–æ—Å—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞')
    return null
  }
  
  console.log(`   üìù –ü–∞—Ä—Å–∏–Ω–≥ —Ç–µ–∫—Å—Ç–∞: "${text.substring(0, 100)}..."`)
  
  // –ò—â–µ–º —Ç–µ–≥–∏
  const tags = []
  const foundTags = text.match(TAG_REGEX)
  
  if (!foundTags || foundTags.length === 0) {
    console.log('   ‚ùå –¢–µ–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã - –ø–æ—Å—Ç –±—É–¥–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω')
    return null
  }
  
  foundTags.forEach(tag => {
    const normalizedTag = tag.toLowerCase()
    tags.push(normalizedTag)
    console.log(`   üè∑Ô∏è –ù–∞–π–¥–µ–Ω —Ç–µ–≥: ${normalizedTag}`)
  })
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –ø–µ—Ä–≤–æ–º—É –Ω–∞–π–¥–µ–Ω–Ω–æ–º—É —Ç–µ–≥—É (–ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É)
  let category = CATEGORY_MAPPING.DEFAULT
  for (const tag of tags) {
    if (CATEGORY_MAPPING[tag]) {
      category = CATEGORY_MAPPING[tag]
      console.log(`   üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${category} (–ø–æ —Ç–µ–≥—É ${tag})`)
      break
    }
  }
  
  if (category === CATEGORY_MAPPING.DEFAULT) {
    console.log(`   üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${category} (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, —Ç–µ–≥–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω—ã: ${tags.join(', ')})`)
  }
  
  // –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∏–º–∞ (–ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –±–µ–∑ —Ç–µ–≥–æ–≤ –∏ —ç–º–æ–¥–∑–∏)
  const lines = text.split('\n').map(line => line.trim()).filter(line => line)
  let title = lines[0] || '–°—Ç—Ä–∏–º'
  
  // –£–±–∏—Ä–∞–µ–º —Ç–µ–≥–∏ –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è
  title = title.replace(TAG_REGEX, '').trim()
  
  // –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏ –∏–∑ –Ω–∞—á–∞–ª–∞ –Ω–∞–∑–≤–∞–Ω–∏—è
  title = removeLeadingEmojis(title)
  
  if (!title) {
    title = '–°—Ç—Ä–∏–º'
  }
  
  console.log(`   üìñ –ù–∞–∑–≤–∞–Ω–∏–µ: "${title}"`)
  
  // –ò—â–µ–º –¥–∞—Ç—É –≤ —Ç–µ–∫—Å—Ç–µ
  let streamDate = null
  const dateMatch = text.match(DATE_REGEX)
  
  if (dateMatch) {
    const dateStr = dateMatch[0]
    console.log(`   üìÖ –ù–∞–π–¥–µ–Ω–∞ –¥–∞—Ç–∞ –≤ —Ç–µ–∫—Å—Ç–µ: ${dateStr}`)
    
    // –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É
    const parts = dateStr.split('.')
    if (parts.length === 3) {
      let [day, month, year] = parts
      
      // –î–æ–ø–æ–ª–Ω—è–µ–º –≥–æ–¥ –µ—Å–ª–∏ –¥–≤—É–∑–Ω–∞—á–Ω—ã–π
      if (year.length === 2) {
        year = '20' + year
      }
      
      streamDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`
    }
  }
  
  // –ï—Å–ª–∏ –¥–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞—Ç—É –ø–æ—Å—Ç–∞ –≤ UTC+5
  if (!streamDate) {
    const postDate = new Date(channelPost.date * 1000)
    // –î–æ–±–∞–≤–ª—è–µ–º 5 —á–∞—Å–æ–≤ –¥–ª—è UTC+5
    const utc5Date = new Date(postDate.getTime() + (5 * 60 * 60 * 1000))
    streamDate = utc5Date.toISOString()
    console.log(`   üìÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞—Ç—É –ø–æ—Å—Ç–∞ (UTC+5): ${streamDate}`)
  } else {
    // –ü–∞—Ä—Å–∏–º –Ω–∞–π–¥–µ–Ω–Ω—É—é –¥–∞—Ç—É –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º—è –∫–∞–∫ —Ç–µ–∫—É—â–µ–µ –≤ UTC+5
    const currentTime = new Date()
    const utc5Time = new Date(currentTime.getTime() + (5 * 60 * 60 * 1000))
    const timeString = utc5Time.toISOString().split('T')[1] // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –≤—Ä–µ–º—è
    streamDate = streamDate + 'T' + timeString
    console.log(`   üìÖ –î–∞—Ç–∞ —Å—Ç—Ä–∏–º–∞ (UTC+5): ${streamDate}`)
  }
  
  return {
    title,
    date: streamDate,
    tags,
    categories: [category],
    messageId: channelPost.message_id,
    chatId: channelPost.chat.id
  }
}

// ============================================================================
// üîó WEBHOOK ENDPOINT
// ============================================================================

// POST /api/webhook - –æ–±—Ä–∞–±–æ—Ç–∫–∞ webhook –æ—Ç Telegram
router.post('/', async (req, res) => {
  console.log('='.repeat(80))
  console.log('üì® –ü–æ–ª—É—á–µ–Ω webhook –æ—Ç Telegram')
  console.log('   –í—Ä–µ–º—è:', new Date().toLocaleString('ru-RU'))
  
  try {
    const update = req.body
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º webhook secret –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
    const webhookSecret = process.env.WEBHOOK_SECRET
    if (webhookSecret) {
      const receivedSecret = req.headers['x-telegram-bot-api-secret-token']
      if (receivedSecret !== webhookSecret) {
        console.log('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π webhook secret')
        return res.status(401).json({ error: 'Unauthorized' })
      }
    }
    
    console.log('‚úÖ Webhook secret –ø—Ä–æ–≤–µ—Ä–µ–Ω')
    console.log('üìã –¢–∏–ø –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', Object.keys(update).join(', '))
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    if (update.message) {
      return await handleUserMessage(update.message, res)
    }
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å—Ç–æ–≤ –∫–∞–Ω–∞–ª–∞
    if (!update.channel_post) {
      console.log('‚ùå –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–∏ channel_post, –Ω–∏ message')
      return res.status(200).json({ ok: true, message: 'Not a channel post or message' })
    }
    
    const channelPost = update.channel_post
    console.log(`üì¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å—Ç–∞ –∫–∞–Ω–∞–ª–∞ ${channelPost.message_id}`)
    console.log(`   –ö–∞–Ω–∞–ª: ${channelPost.chat.title || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'} (ID: ${channelPost.chat.id})`)
    
    // –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç–∞
    const streamData = parsePost(channelPost)
    
    if (!streamData) {
      console.log('‚ùå –ü–∞—Ä—Å–∏–Ω–≥ –Ω–µ—É–¥–∞—á–µ–Ω –∏–ª–∏ –ø–æ—Å—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä–∏–º–æ–≤')
      return res.status(200).json({ ok: true, message: 'No stream data parsed' })
    }
    
    // ========================================================================
    // üíæ –°–û–•–†–ê–ù–ï–ù–ò–ï –í –ë–ê–ó–£ –î–ê–ù–ù–´–•
    // ========================================================================
    
    console.log('üíæ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö...')
    const db = await getDatabase()
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
    const existingStream = await db.get(`
      SELECT id FROM streams WHERE message_id = ? AND chat_id = ?
    `, [streamData.messageId, streamData.chatId])
    
    if (existingStream) {
      console.log('‚ö†Ô∏è –°—Ç—Ä–∏–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –±–∞–∑–µ')
      return res.status(200).json({ ok: true, message: 'Stream already exists' })
    }
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç
    const channelUsername = process.env.TELEGRAM_CHANNEL_USERNAME || 'channel'
    const telegramUrl = `https://t.me/${channelUsername}/${streamData.messageId}`
    console.log(`üîó –°—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç: ${telegramUrl}`)
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–µ–≤—å—é
    const thumbnailData = await generateThumbnail(telegramUrl)
    
    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Å—Ç—Ä–∏–º–∞
    const result = await db.run(`
      INSERT INTO streams (
        title, telegram_url, stream_date, tags, categories,
        thumbnail_url, thumbnail_source, thumbnail_public_id, 
        thumbnail_width, thumbnail_height, thumbnail_format, thumbnail_bytes,
        thumbnail_updated_at, message_id, chat_id, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
    `, [
      streamData.title,
      telegramUrl,
      streamData.date,
      JSON.stringify(streamData.tags),
      JSON.stringify(streamData.categories),
      thumbnailData?.url || null,
      thumbnailData?.source || null,
      thumbnailData?.publicId || null,
      thumbnailData?.width || null,
      thumbnailData?.height || null,
      thumbnailData?.format || null,
      thumbnailData?.bytes || null,
      thumbnailData ? new Date().toISOString() : null,
      streamData.messageId,
      streamData.chatId
    ])
    
    console.log('üéâ –°–¢–†–ò–ú –£–°–ü–ï–®–ù–û –î–û–ë–ê–í–õ–ï–ù!')
    console.log(`   üìñ –ù–∞–∑–≤–∞–Ω–∏–µ: ${streamData.title}`)
    console.log(`   üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${streamData.categories[0]}`)
    console.log(`   üè∑Ô∏è –¢–µ–≥–∏: ${streamData.tags.join(', ')}`)
    console.log(`   üñºÔ∏è –ü—Ä–µ–≤—å—é: ${thumbnailData ? `–î–ê (${thumbnailData.source})` : '–ù–ï–¢'}`)
    console.log(`   üÜî ID –≤ –±–∞–∑–µ: ${result.lastID}`)
    
    return res.status(200).json({
      ok: true,
      message: 'Stream added successfully',
      stream: {
        id: result.lastID,
        title: streamData.title,
        category: streamData.categories[0],
        tags: streamData.tags,
        thumbnail: !!thumbnailData
      }
    })
    
  } catch (error) {
    console.error('üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê:', error)
    console.error('Stack trace:', error.stack)
    
    return res.status(500).json({
      error: 'Internal server error',
      message: error.message
    })
    
  } finally {
    console.log('='.repeat(80))
  }
})

export default router 